# 本地缓存选项和映射

现在让我们一起花些时间来回归一下我们学的三个功能：映射、缩写和配置项，但是换一种方式：我们每次都在一个缓存里来设置它们。

缓存真正的强大要到下一个章节你才会知道，不过本章我们先学一些基础的东西。

现在，你需要打开两个文本，每一个文本一个独立的窗口。两个文件分别命名为foo和bar，不过你可以随意命名它们。分别向两个窗口里输入文本。

# 映射

切换到foo文件里，运行下面的命令：
`:nnoremap <leader>d dd`
`:nnoremap <buffer> <leader>x dd`
     
在foo文件里，确保你在normal模式下，然后输入<leader>键+d。vim会删除当前行。这个我们早就知道了。

还是在foo文件里，输入<leader>键+x，vim又删除了一行文本。这个貌似没什么新奇的，因为我们把<leaer>+x映射成了dd的功能。

现在切换到bar文件里。在normal模式下，输入<leader>键+d。同意的vim会删除一行文本。也没啥稀奇的。

现在来看看不同的地方：还是在bar文件里，输入<leader>键+x。

什么都没有出现！

第二个映射命令里的<buffer>告诉vim这个映射只会在定义它的那个缓存里有效。

# 本地Leader键

在上面的例子里，我们用了<leader>+x来设置本地缓存映射，但是这个是个不好的方式。一般来说，当你要创建一个供特定缓存使用的本地映射时，你应该用<localleader>而不是用<leader>。

分别用两个不同的前导键，提供了一个类似于“命名空间”的功能，这样可以让不同的映射不至于混淆。

尤其是当你在给其他人提供插件的时候，用<localleader>来做本地映射就不会让你的插件覆盖了其他人的花了不少时间记住的<leader>键的映射。

# 设置

在前面的章节里，我们讨论了用如何用set命令来设置配置项的。有些选项需要定义成全局的，但是有些则是设置给对应的缓存的。

切换到foo文件里，运行下面的命令：
`:setlocal wrap`

再切换到bar文件里，运行下面的命令：
`:setlocal nowrap`

现在把vim的窗口调小，你会发现当文本超过窗口的宽度的时候，foo文件里的文本会自动换行，而bar里的文本则不会。
     
再试试另外一个选项，切换到foo文件，运行下面的命令：
`:setlocal number`

现在，切换到bar文件，运行下面的命令：
`:setlocal nonumber`

你会发现foo文件里有行号，而bar文件里没有
 
# 覆盖

在我们继续下一节之前，先看看一个本地映射的一个有趣的特点。切换到foo文件里，运行下面的命令：
`:nnoremap <buffer> Q x`
`:nnoremap Q d`

在foo文件里输入Q，会出现什么呢？

当你输入Q时，Vim会运行第一个命令，但为什么不是第二个呢？这是因为第一个映射相对于第二个而言更加明确。

切换到bar文件里输入Q，你会发现vim用了第二个映射，因为在这里它没有被第一个所覆盖。

# 练习

- 阅读:help setlocal
- 阅读:help map-local
